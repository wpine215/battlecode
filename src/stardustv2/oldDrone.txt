package stardustv2;
import battlecode.common.*;

import java.util.*;

public strictfp class Drone {
    static RobotController rc;
    static Utility ut;
    static int mapHeight;
    static int mapWidth;
    static Direction[] directions = Utility.getDirections();

    enum ObstacleDir {
        UNASSIGNED,
        LEFT,
        RIGHT
    }

    static int resetRounds;
    static boolean followingObstacle;
    static boolean inOrbit;
    static int justHitMapEdge = 0;
    static Direction currentDirection;
    static ArrayList<MapLocation> currentMLine;
    static Set<MapLocation> currentMLineSet;
    static ObstacleDir obstacleDir;
    static LinkedList<MapLocation> lastXLocations;

    public Drone(RobotController rc, MapLocation localHQ) {
        Drone.rc = rc;
        Drone.mapHeight = rc.getMapHeight();
        Drone.mapWidth = rc.getMapWidth();
        Drone.ut = new Utility(rc, mapHeight, mapWidth, localHQ);

        currentMLine = new ArrayList<>();
        currentMLineSet = new HashSet<>();
        followingObstacle = false;
        inOrbit = false;
        resetRounds = 0;
        obstacleDir = ObstacleDir.UNASSIGNED;
        lastXLocations = new LinkedList<>();
    }

    private void locationPushBack(MapLocation loc) throws GameActionException {
        if (lastXLocations.size() >= 4) {
            lastXLocations.removeLast();
        }
        lastXLocations.addFirst(loc);
    }

    public boolean circleAround(MapLocation dest, int radiusSquared) throws GameActionException {
        // Returns true if movement in progress
        // Returns false if journey complete or obstacle encountered
        if (!currentMLine.isEmpty()) {
            drawPersistentMLine();
        }

        Random rand = new Random();

        // If no m-line exists, we haven't performed path calculations yet
        if (currentMLine.isEmpty()) {
            getMLine(rc.getLocation(), dest);
            currentDirection = rc.getLocation().directionTo(dest);
        }

        // Already at destination - is this necessary?
        if (rc.getLocation().equals(dest)) {
            System.out.println(">>>>> Already at destination!");
            currentMLine.clear();
            currentMLineSet.clear();
            return false;
        }

        // We encountered a map edge
        if (Pathfinding.isLocationMapEdge(rc.getLocation()) && justHitMapEdge == 0) {
            currentDirection = currentDirection.opposite();
            if (obstacleDir == ObstacleDir.LEFT) {
                obstacleDir = ObstacleDir.RIGHT;
            } else {
                obstacleDir = ObstacleDir.LEFT;
            }
            justHitMapEdge = 1;
        }
        if (justHitMapEdge == 1) {
            justHitMapEdge = 2;
        } else if (justHitMapEdge == 2) {
            justHitMapEdge = 0;
        }

        if (obstacleDir != ObstacleDir.UNASSIGNED && rc.getLocation().isWithinDistanceSquared(dest, radiusSquared + 10)) {
            inOrbit = true;
        }

        if (inOrbit && rc.getLocation().distanceSquaredTo(dest) > radiusSquared+10) {
            inOrbit = false;
        }

        // If we're on m-line, try moving directly to target
        if (locationOnMLine(rc.getLocation()) && !inOrbit) {
            // Get next point on m-line and try moving to it
            MapLocation next = getNextPointOnMLine(rc.getLocation());
            Direction nextDir = rc.getLocation().directionTo(next);
            if (rc.canMove(nextDir) && (radiusSquared == 0 || !next.isWithinDistanceSquared(dest, radiusSquared))) {
                locationPushBack(rc.getLocation());
                rc.move(nextDir);
                currentDirection = nextDir;
                return true;
            } else {
                // Obstacle at next point on m-line, so do some following
                int initialDir;
                if (rc.canMove(nextDir.rotateLeft())
                        && !rc.senseFlooding(rc.adjacentLocation(nextDir.rotateLeft()))
                        && (radiusSquared == 0 || !rc.adjacentLocation(nextDir.rotateLeft()).isWithinDistanceSquared(dest, radiusSquared))) {
                    initialDir = 0;
                } else if (rc.canMove(nextDir.rotateRight())
                        && !rc.senseFlooding(rc.adjacentLocation(nextDir.rotateRight()))
                        && (radiusSquared == 0 || !rc.adjacentLocation(nextDir.rotateRight()).isWithinDistanceSquared(dest, radiusSquared))) {
                    initialDir = 1;
                } else {
                    initialDir = rand.nextInt(2);
                }

                if (initialDir == 0) {
                    System.out.println(">>>>> Starting to follow obstacle left!");
                    obstacleDir = ObstacleDir.LEFT;
                    return followObstacleLeft(true, dest, radiusSquared);
                } else {
                    System.out.println(">>>>> Starting to follow obstacle right!");
                    obstacleDir = ObstacleDir.RIGHT;
                    return followObstacleRight(true, dest, radiusSquared);
                }

            }
        } else {
            // Still following obstacle
            if (obstacleDir == ObstacleDir.LEFT) {
                System.out.println(">>>>> STILL following obstacle left!");
                return followObstacleLeft(false, dest, radiusSquared);
            } else if (obstacleDir == ObstacleDir.RIGHT) {
                System.out.println(">>>>> STILL following obstacle right!");
                return followObstacleRight(false, dest, radiusSquared);
            }
        }
        return false;
    }

    private void getMLine(MapLocation src, MapLocation dest) throws GameActionException {
        currentMLine.add(src);
        currentMLineSet.add(src);
        MapLocation temp = src;
        while(!temp.equals(dest)) {
            currentMLine.add(temp.add(temp.directionTo(dest)));
            currentMLineSet.add(temp.add(temp.directionTo(dest)));
            temp = temp.add(temp.directionTo(dest));
        }
        currentMLine.add(dest);
        currentMLineSet.add(dest);
    }

    private MapLocation getNextPointOnMLine(MapLocation loc) throws GameActionException {
        int resultIndex = currentMLine.indexOf(loc) + 1;
        if (resultIndex < currentMLine.size()) {
            return currentMLine.get(resultIndex);
        }
        return new MapLocation(-1, -1);
    }

    private boolean locationOnMLine(MapLocation loc) throws GameActionException {
        return currentMLineSet.contains(loc);
    }

    private boolean followObstacleLeft(boolean firstTime, MapLocation dest, int radiusSquared) throws GameActionException {
        if (currentDirection == null) {
            return false;
        }
        Direction[] moveQueue = new Direction[7];
        moveQueue[2] = currentDirection;
        moveQueue[1] = moveQueue[2].rotateRight();
        moveQueue[0] = moveQueue[1].rotateRight();
        moveQueue[3] = moveQueue[2].rotateLeft();
        moveQueue[4] = moveQueue[3].rotateLeft();
        moveQueue[5] = moveQueue[4].rotateLeft();
        moveQueue[6] = moveQueue[5].rotateLeft();

        if (firstTime) {
            // override opposite diagonal if first time
            moveQueue[0] = currentDirection;
            moveQueue[1] = currentDirection;
        }

        for (Direction dir : directions) {
            if (rc.canMove(dir)
                    && !inOrbit
                    && locationOnMLine(rc.adjacentLocation(dir))
                    && (radiusSquared == 0 || !rc.adjacentLocation(dir).isWithinDistanceSquared(dest, radiusSquared))
                    && !lastXLocations.contains(rc.adjacentLocation(dir))) {
                locationPushBack(rc.getLocation());
                rc.move(dir);
                currentDirection = dir;
                return true;
            }
        }

        for (Direction dir : moveQueue) {
            if (rc.canMove(dir)
                    && (radiusSquared == 0 || !rc.adjacentLocation(dir).isWithinDistanceSquared(dest, radiusSquared))
                    && !lastXLocations.contains(rc.adjacentLocation(dir))) {
                locationPushBack(rc.getLocation());
                rc.move(dir);
                currentDirection = dir;
                rc.setIndicatorDot(rc.adjacentLocation(dir), 0, 100, 255);
                return true;
            } else {
                rc.setIndicatorDot(rc.adjacentLocation(dir), 255, 100, 50);
            }
        }
        return false;
    }

    private boolean followObstacleRight(boolean firstTime, MapLocation dest, int radiusSquared) throws GameActionException {
        if (currentDirection == null) {
            return false;
        }
        Direction[] moveQueue = new Direction[7];
        moveQueue[2] = currentDirection;
        moveQueue[1] = moveQueue[2].rotateLeft();
        moveQueue[0] = moveQueue[1].rotateLeft();
        moveQueue[3] = moveQueue[2].rotateRight();
        moveQueue[4] = moveQueue[3].rotateRight();
        moveQueue[5] = moveQueue[4].rotateRight();
        moveQueue[6] = moveQueue[5].rotateRight();

        if (firstTime) {
            // override opposite diagonal if first time
            moveQueue[0] = currentDirection;
            moveQueue[1] = currentDirection;
        }

        for (Direction dir : directions) {
            if (rc.canMove(dir)
                    && !inOrbit
                    && locationOnMLine(rc.adjacentLocation(dir))
                    && (radiusSquared == 0 || !rc.adjacentLocation(dir).isWithinDistanceSquared(dest, radiusSquared))
                    && !lastXLocations.contains(rc.adjacentLocation(dir))) {
                locationPushBack(rc.getLocation());
                rc.move(dir);
                currentDirection = dir;
                return true;
            }
        }

        for (Direction dir: moveQueue) {
            if (rc.canMove(dir)
                    && (radiusSquared == 0 || !rc.adjacentLocation(dir).isWithinDistanceSquared(dest, radiusSquared))
                    && !lastXLocations.contains(rc.adjacentLocation(dir))) {
                locationPushBack(rc.getLocation());
                rc.move(dir);
                currentDirection = dir;
                rc.setIndicatorDot(rc.adjacentLocation(dir), 0, 100, 255);
                return true;
            } else {
                rc.setIndicatorDot(rc.adjacentLocation(dir), 255, 100, 50);
            }
        }
        return false;
    }

    public void drawPersistentMLine() throws GameActionException {
        for (MapLocation point : currentMLine) {
            rc.setIndicatorDot(point, 0, 0, 0);
        }
    }

}
